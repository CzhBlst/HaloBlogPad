# 深入理解Java虚拟机
感觉这一部分需要常常回顾，因此不适合放在周记之中，故开此篇
## 类的加载

### 类的加载
Java中的类型加载、连接、初始化均在程序运行期间完成
+ 加载
将字节码装入内存中，生成Class对象
+ 链接
将类的二进制代码合并到JVM的运行状态之中的过程
	+ 验证：验证类符合规范
	+ 准备：分配内存（为数据分配默认值等等）
	+ 解析：将引用替换为地址的过程
+ 初始化
	+ 执行类构造器的初始化方法 <clinit>()，此方法是由JVM自动生成的，与类中数据，静态数据处理块等影响
	+ 该方法会优先将static数据进行处理（处理顺序按语句先后顺序来）
	+ 虚拟机会保证一个类的<clinit>()方法在多线程中被正确加锁与同步

### 类初始化
+ 类的主动引用
	+ 虚拟机启动，初始化main
	+ new
	+ 调用类的静态成员与静态方法
	+ 使用反射调用
	+ 调用子类时对父类的初始化
+ 被动引用（不会初始化）
	+ 调用静态成员时只会初始化声明该成员的类，如通过子类引用父类中的静态方法，不会导致子类被初始化
	+ 通过数组定义类引用
	+ 引用常量（static final int H = 1; 常量在链接阶段就会被加载）

### 类缓存
类被加载时会维持一段时间，之后被JVM回收掉

### 类加载器
自顶向下加载类，自底向上检查类是否被加载
+ Bootstrap Classloader
加载核心类库 
+ Extension Classloader
将jre/lib/ext目录下的jar包加载
+ System Classloader
将-D java.class.path所指向的目录下的类与jar包装入
加载方式
+ 从本地系统直接加载
+ 通过网络下载.class加载
+ jar包里加载
+ 从专有数据库加载
+ 将Java源文件编译为.class（即该类仅在运行时才有，而编译期间没有此类，例如Servlet，运行时注解等）

### 双亲委派

### Class中的常用方法
+ getField() 获取public属性
+ getDeclaredField() 获取本类全部属性
+ getMethods() 获取所有方法
+ getDeclaredMethods() 获取本类的所有方法
+ getConstructor() 获取构造器
+ getDeclaredConstructor() 获取本类全部构造器
+ newInstance()获取一个新的对象
### 动态创建对象
即从Class中获取对象，可以通过newInstance或是Constructor获取对象
或是通过Class获取方法，通过Method.invoke调用方法
```java
//通过反射操作方法
	OriAnno ori2 = (OriAnno) c1.newInstance();
        System.out.println(ori2.getName());
        Method setName = c1.getDeclaredMethod("setName", String.class);
        setName.invoke(ori2, "czh");
        System.out.println(ori2.getName());
//通过反射操作方法
	Field field = c1.getDeclaredField("name");
        System.out.println(field.getName());
        System.out.println("###########################");
        field.setAccessible(true); //关闭安全检测
        field.set(ori2, "father");
        System.out.println(ori2.getName());
        System.out.println("###########################");
	
```
## 自动内存管理
### Java内存区域与内存溢出异常
#### 运行时数据区域
+ 方法区
	+ 线程共享的内存区域，用来存储类型信息、常量、静态变量、即时编译器编译后代码缓存
	+ 运行时常量池，这部分存储Class文件中的常量池表（存放编译期生成的各种字面量与符号引用）
	+ 例如final修饰的数据会被存储到调用该常量的方法的运行时常量池，而无需加载或初始化存储该常量的类
	+ 无法继续分配内存时抛出OutOfMemory异常
	
+ 虚拟机栈
	+ 描述Java方法执行的线程内存模型，每一个方法的执行都会创建一个栈帧来存储局部变量表、操作数栈、动态连接、方法出口等信息
	+ 局部变量表中的数据表示：局部变量槽Slot，一个Slot为32bit，long double占两个Slot
	+ 该内存区域有两类异常，线程请求深度超过栈深度的StackOverflowError，可动态扩展栈申请不到内存的OutOfMemoryError
+ 本地方法栈
	+ Native栈与虚拟机栈类似
	+ 异常与虚拟机栈相同
+ 堆
	+ 线程共享，运行时数据区域，用来存放对象实例
	+ 堆是GC的管理区域，也有GC堆的叫法
	+ 基于不同的GC，堆也有着不同的叫法，Eden空间 Survivor空间等
	+ 大部分堆是可扩展的，无法申请到内存会抛出OutOfMemory异常
+ 程序计数器
	+ Java的class文件中是字节码，JVM解析字节码来实现程序运行，JVM中PC用来指明下一条字节码的地址
	+ Java多线程是通过线程切换实现的，因此JVM中每个线程都有一个PC，且互不影响
	+ 这类线程间无法共享的内存区域称为“线程私有”内存
	+ 如果线程执行的是Java方法，则PC值为字节码地址，若是Native方法（调用C程序等），则为空（Undefined）
	+ 此区域是唯一一个Java虚拟机规范中没有定义OutOfMemoryError的区域
