# Flink结构介绍
一种实时数据处理框架，可以拿来跟SparkStream进行比较

## 流数据

## 传统数据处理架构
+ 事务处理模型
	+ 现在一般使用微服务构成大型应用来处理用户事务	
	+ 多个微服务之间的通信（指获取数据）使用RESTful接口来进行
	+ 对于用户来的数据进行一个一个的处理，再返回给前台
	+ 缺点在于
		1. 关系型数据库的联立查询比较慢
+ 数据分析模型
	+ 将数据进行处理（ETL）并存储到数仓进行分析

## 状态流式处理模型
+ 状态：指函数处理后所得的结果
	+ 这种处理模型将计算和计算对应的状态进行分离，使得计算得以并行，状态得以共享
+ 事件日志：有状态的流式处理应用一般从Event Log中读取接下来的事件，这类日志只能追加、可以被多个流式应用获取，一般使用Kafka这类消息队列来进行日志的存储
	+ 特征，事件日志很可能是无界的，即存在EventLog中会不断地有新的事务产生

### Lambda架构
使用批处理 + 流式处理的方式来保证结果的正确性
+ 即从EventLog中读取的事件，需要发送给两套处理模型，一个保证速度，一个保证正确
+ 其主要目的在于提高批处理事件得到结果的速度
+ 缺点在于同一事件需要计算两次，（它费电啊！）

## 一些基础概念
+ slot，插槽，Flink中的资源处理单元，每个插槽可执行一个任务
+ 并行度，取决与算子最大子任务个数
+ source，数据源
+ sink，数据流向
	+ 这两个概念与Flume中的source和sink基本一致，只是flink中无需配置channel

### Flink运行时处理架构
下面四个组件在流处理程序协同工作，流程为用户通过Dispatcher提交作业→JobManager申请Slots→ResourceManager注册需要的Slots并告知其所在的TaskManager→TaskManager向JobManager提供Slot→JobManager提交任务给TaskManager→开始执行
___需要注意的是Yarn中也有ResourceManager，应加以区别___
+ 作业管理器，
	+ 管理用户提交的应用程序，包括Jar包、作业图、逻辑数据流图，并将作业图转化为执行图（即任务执行次序）
	+ 向资源管理器申请资源，申请到后会将执行图发送到任务管理器
+ 资源管理器
	+ 负责管理Slot，主要是将可用的Slot告诉给作业管理器，Slot不足时向Yarn申请新的资源
+ 任务管理器
	+ 执行任务的具体单位，每个TaskManager都有一个或多个Slot
+ 分发器
	+ 用户提交任务的RESTful接口


### 关于作业占用Slot的个数
某个作业占用几个Slot取决于其任务的并行度，串行的任务可以放在同一个Slot中执行，并行的则需要占用多个Slot


# 算子操作
Flink Java Api中并非全部的算子都可以使用Lambda表达式
例如FlatMap
官方给出的意见如下：
> Unfortunately, functions such as flatMap() with a signature void flatMap(IN value, Collector<OUT> out) are compiled into void flatMap(IN value, Collector out) by the Java compiler. This makes it impossible for Flink to infer the type information for the output type automatically.

