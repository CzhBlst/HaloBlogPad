# Sql99语法
## 语法
	SELECT 查询列表
	FROM 表1
	[JOIN_TYPE] JOIN table2 
	ON 连接条件
	WHERE 筛选
	····ORDER GROUP与之前的一样 
其中JOIN_TYPE指的就是下面的这些类型

+ 内连接 INNER
与92一样，等值、非等值、自连接，案例练习一次即可
查询结果为两个表的交集
注意事项 inner可以省略
+ 外连接
一般用于查询一个表中有，另一个表中没有的记录（即查询某一个表中的全部记录并且题目中往往要求是另一个表中没有的部分）
显示结果为主表中的所有记录 = 内连接结果+主表有从表没有的记录
从表中与他匹配的所有记录，不匹配的记录会填充为null
左外与右外只是表顺序的不同
 EX : 查询没有男朋友的女神名字	
+ 左外 LEFT
左边是主表
+ 右外 RIGHT
右边是主表
+ 全外	 FULL
结果是左(右)外的结果 + 从表中的所有记录
+ 交叉连接 CROSS JOIN
返回两个表的笛卡尔乘积，与92语法的','一样

各类外连接结果如下图所示
![各类连接返回结果示例1](http://121.4.203.203:8090/upload/2021/06/image-2b91832e08ad47bb8024a22849b115d6.png) ![各类连接返回结果示例2](http://121.4.203.203:8090/upload/2021/06/image-68c729af47e74f2dadb48d36f94a384c.png)

## 练习
1. 查询编号>3的女神的男朋友信息，如果有则列出详细，如果没有，用null填充
2. 查询哪个城市没有部门
3. 查询部门名为SAL或IT的员工信息

```
# 1
USE girls;

SELECT b.*, g.id
FROM boys b
LEFT JOIN beauty g
ON b.id = g.boyfriend_id
WHERE g.id > 3;

# 这个是错误的，注意要查出所有id>3的女神的男朋友信息，下面这个是正确的
USE girls;

SELECT b.*, g.id as girl_id
FROM beauty g
LEFT JOIN boys b
ON b.id = g.boyfriend_id
WHERE g.id > 3
ORDER BY b.id;


# 2
USE myemployees;

SELECT city
FROM locations l
LEFT JOIN departments d 
ON l.location_id = d.location_id
WHERE d.department_id IS NULL;

# 3 
USE myemployees;

SELECT d.department_name, e.*
FROM employees e
INNER JOIN departments d
ON e.department_id = d.department_id
WHERE d.department_name = 'SAL' OR d.department_name = 'IT';

# 注意第三个也是错误，与第一题同样，我们需要查询所有部门名为IT或SAL的部门中的员工，没有员工应该用NULL填充 
USE myemployees;

SELECT d.department_name, e.*
FROM departments d
LEFT JOIN employees e
ON e.department_id = d.department_id
WHERE d.department_name IN('SAL', 'IT');
```

# 子查询
出现在其他语句中的SELECT语句，称为子查询或内查询
外部的查询语句，称为主查询或外查询

例如
```
SELECT first_name from employees where departmetn_id in (
	select department_id from departments
	where location_id = 1700
);
```

## 分类
+ 按子查询出现的位置：
	+ SELECT后面，只支持标量子查询
	+ FROM后面，支持表子查询
	+ WHERE HAVING后面，标量、列子查询，行子查询用的少
	+ EXISTS后面，支持表子查询
+ 按结果分类：
	+ 标量子查询（结果集只有一行一列）
	+ 列子查询（结果集一列多行）
	+ 行子查询（结果集一行多列）
	+ 表子查询（结果集任意）

注意事项：
子查询一般在条件右侧
标量子查询一般搭配单行操作符使用
列子查询一般搭配多行操作符

## 练习
1. 查询和Zlotkey相同部门的员工姓名和工资
2. 查询工资比公司平均工资高的员工的员工号，姓名和工资。
3. 查询各部门中工资比本部门平均工资高的员工的员工号, 姓名和工资
4. 查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名
5. 查询在部门的location_id为1700的部门工作的员工的员工号
6. 查询管理者是King的员工姓名和工资
7. 查询工资最高的员工的姓名，要求first_name和last_name显示为一列，列名为 姓.名


```
# 1
SELECT last_name, salary, e.department_id
FROM employees e
WHERE e.department_id = (
	SELECT department_id
	FROM employees e2
	WHERE e2.last_name = 'Zlotkey'
);

# 2
SELECT employee_id, last_name, salary
FROM employees
WHERE salary > (
	SELECT AVG(salary)
	FROM employees
);

# 3 
SELECT employee_id, last_name, salary, (
	SELECT AVG(salary)
	FROM employees e2
	WHERE e1.department_id = e2.department_id
) as avg_dep, department_id
FROM employees e1
WHERE salary > (
	SELECT AVG(salary)
	FROM employees e2
	WHERE e1.department_id = e2.department_id
);
# 3 或是
SELECT employee_id, last_name, salary, avg_dep.avg_s
FROM employees e
INNER JOIN (
	SELECT department_id, AVG(salary) as avg_s
	FROM employees
	GROUP BY department_id
) as avg_dep
ON e.department_id = avg_dep.department_id
WHERE e.salary > avg_dep.avg_s
ORDER BY avg_dep.avg_s;


# 4 ??
SELECT employee_id, last_name, department_id
FROM employees e1
WHERE last_name LIKE '%u%'
AND e1.department_id IN (
	SELECT department_id
	FROM employees e2
	WHERE e1.department_id = e2.department_id
	AND e2.last_name LIKE '%u%'
);

# 5
SELECT employee_id, department_id
FROM employees
WHERE department_id IN (
	SELECT department_id
	FROM departments
	WHERE location_id = 1700
);

# 6
SELECT last_name, salary, manager_id
FROM employees
WHERE manager_id = (
	SELECT employee_id
	FROM employees
	WHERE last_name = 'King'
);

# 7
SELECT CONCAT(first_name, ' ', last_name) as 'Name', salary
FROM employees
WHERE salary = (
	SELECT MAX(salary)
	FROM employees
);
```

## 查询经典案例
1. 查询工资最低的员工信息: last_name, salary
2. 查询平均工资最低的部门信息
3. 查询平均工资最低的部门信息和该部门的平均工资
4. 查询平均工资最高的 job 信息
5. 查询平均工资高于公司平均工资的部门有哪些?
6. 查询出公司中所有 manager 的详细信息.
7. 各个部门中 最高工资中最低的那个部门的 最低工资是多少
8. 查询平均工资最高的部门的 manager 的详细信息: last_name, department_id, email, salary
```
# 1
SELECT last_name, salary
FROM employees
WHERE salary = (
	SELECT MIN(salary)
	FROM employees	
);

# 2
SELECT d.*
FROM departments d
WHERE d.department_id IN (
	SELECT department_id
	FROM employees
	GROUP BY department_id
	HAVING AVG(salary)=(
		SELECT MIN(ag)
		FROM (
			SELECT AVG(salary) ag,department_id
			FROM employees
			GROUP BY department_id
		) ag_dep
	)
);

# 3
SELECT d.*, ag_dep.ag
FROM departments d
INNER JOIN (
	SELECT AVG(salary) ag,department_id
	FROM employees
	GROUP BY department_id
) ag_dep
ON d.department_id = ag_dep.department_id
WHERE d.department_id IN (
	SELECT department_id
	FROM employees
	GROUP BY department_id
	HAVING AVG(salary)=(
		SELECT MIN(ag)
		FROM (
			SELECT AVG(salary) ag,department_id
			FROM employees
			GROUP BY department_id
		) ag_dep
	)
); 

# 3 或是利用LIMIT来查询最低平均工资
SELECT d.*, ag_dep.ag
FROM departments d
INNER JOIN (
	SELECT AVG(salary) ag,department_id
	FROM employees
	GROUP BY department_id
) ag_dep
ON d.department_id = ag_dep.department_id
WHERE d.department_id IN (
	SELECT department_id
	FROM employees
	GROUP BY department_id
	HAVING AVG(salary)=(
		SELECT AVG(salary)
		FROM employees
		GROUP BY department_id
		ORDER BY AVG(salary) DESC
		LIMIT 1
	)
);

# 4
SELECT j.*
FROM jobs j
WHERE j.job_id IN (
	SELECT job_id
	FROM employees
	GROUP BY job_id
	HAVING AVG(salary) = (
		SELECT MAX(avg_s)
		FROM (
			SELECT AVG(salary) avg_s, job_id
			FROM employees
			GROUP BY job_id
		) as avg_job
	)
);	


# 5
SELECT d.*
FROM departments d
WHERE d.department_id IN (
	SELECT department_id
	FROM employees
	GROUP BY department_id
	HAVING AVG(salary) > (
		SELECT AVG(salary)
		FROM employees
	));

# 6
SELECT DISTINCT e1.employee_id, e2.manager_id
FROM employees e1
INNER JOIN employees e2
ON e2.manager_id = e1.employee_id

# 或使用子查询
SELECT DISTINCT *
FROM employees
WHERE employee_id IN(
	SELECT DISTINCT manager_id
	FROM employees
);

# 7

SELECT MIN(max_s)
FROM (
	SELECT max_s
	FROM (
		SELECT MAX(salary) as max_s, department_id
		FROM employees
		GROUP BY department_id
	) as tmp ) as max_dep;

# 8 
SELECT last_name, e.department_id, e.email, salary
FROM employees e
INNER JOIN departments d
ON d.department_id = e.department_id
WHERE e.department_id = (
	SELECT department_id
	FROM employees
	GROUP BY department_id
	HAVING MAX(salary) = (
		SELECT MAX(avg_s)
		FROM (
			SELECT MAX(salary) avg_s, department_id
			FROM employees	
			GROUP BY department_id
		) as ag_dep
	)
) 
AND d.manager_id = e.employee_id

# 利用LIMIT求最大值
SELECT last_name, e.department_id, e.email, salary
FROM employees e
INNER JOIN departments d
ON d.department_id = e.department_id
WHERE e.department_id = (
	SELECT department_id
	FROM employees
	GROUP BY department_id
	ORDER BY AVG(salary) DESC
	LIMIT 1
)
AND d.manager_id = e.employee_id

```

# 联合查询
将多条查询语句合并得到一个结果
当需要一次查询两个表中的数据，但是两个表中的数据无连接条件，且要查的数据一致，可以使用联合查询
使用UNION关键字默认去重
UNION ALL则不去重

# 关键字执行顺序
![各关键字的执行顺序](http://121.4.203.203:8090/upload/2021/06/image-cc3fc56ee3574820a7a384fbff7c64c9.png)

# 杂记
斯特林公式：阶乘逼近公式
<div align=center><img src="http://121.4.203.203:8090/upload/2021/06/image-800180202fe34dbaa84a0a1c044fa442.png" title = "斯特林公式"></div>